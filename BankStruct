// SPDX-License-Identifier: EPL-2.0

pragma solidity ^0.8.26;

contract BankStruct {
    constructor() payable {
        bankAdmin = msg.sender;
        setupFee = 10 gwei;
    }

    receive() external payable {}

    fallback() external payable {}

    struct Cust {
        bool valid;
        uint balance;
    }
    mapping (address => Cust) private custs;

    uint private setupFee;

    address immutable private bankAdmin;

    modifier isBank {
        require(msg.sender == bankAdmin);
        _;
    }

    modifier isNotBank {
        require(msg.sender != bankAdmin);
        _;
    }

    modifier isCustomer {
        require(custs[msg.sender].valid);
        _;
    }

    modifier isNotCustomer {
        require(custs[msg.sender].valid == false);
        _;
    }

    function newCustomer() isNotCustomer isNotBank external payable returns (uint) {
        address _addr = msg.sender;
        require(uint (msg.value) == setupFee);
        custs[_addr].valid = true;
        return custs[_addr].balance;
    }

    function deposit() isCustomer external payable returns (uint) {
        custs[msg.sender].balance += msg.value;
        return custs[msg.sender].balance;
    }

    function withdraw(uint _amount) isCustomer external returns (uint) {
        address _addr = msg.sender;
        require(_amount <= custs[_addr].balance);

        custs[_addr].balance -= _amount;
        (bool success, ) = _addr.call{value: _amount}("");
        require(success);
        return custs[_addr].balance;
    }

    function custBalance() isCustomer external view returns (uint) {
        return custs[msg.sender].balance;
    }

    function getFee() external view returns (uint) {  
        return setupFee;  
    }

    function setFee(uint _fee) isBank external {
        setupFee = _fee;
    }

    function totalAssets() isBank external view returns (uint) {
        return address(this).balance;
    }
}
